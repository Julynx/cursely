#!/usr/bin/env python3

"""
@file     cursely
@date     23/06/2023
@author   Julio Cabria
"""

import sys
import os
import json
import subprocess
import multiprocessing
from itertools import repeat
from time import sleep, time
import requests
from prettytable import PrettyTable, SINGLE_BORDER
from numerize.numerize import numerize

BASE_URL = "https://api.curseforge.com"
CONFIG_PATH = os.path.expanduser("~/.config/cursely/config.json")

TERM_SIZE = os.get_terminal_size()
TERM_WIDTH = TERM_SIZE.columns
TERM_HEIGHT = TERM_SIZE.lines
MODPACK_DOWNLOAD_THREADS = os.cpu_count() * 2
MODPACK_DOWNLOAD_RETRIES = 3
MODPACK_TIME_BETWEEN_RETRIES = 1


USAGE_INFO = """
Usage:
    cursely             Browse popular recently updated mods.
    cursely [MOD_ID]    Get a brief description of a mod and its download link.
    cursely [KEYWORD]   Search for a mod by its name or author.
    cursely [MODPACK]   Install all listed mods and their dependencies.
    cursely --help      Show this help message.
"""


def modpack_mod(mod_id, cfg):
    """
    Download a mod.

    Args:
        mod_id (int): The mod ID.
        cfg (dict): The config dictionary.

    Returns:
        None if the mod was downloaded successfully, otherwise the mod ID.
    """
    tries = MODPACK_DOWNLOAD_RETRIES
    while tries > 0:

        url = mod_download_link(mod_id, cfg)

        cmd = f"wget -P '{cfg['mods_path']}' '{url}' > /dev/null 2>&1"
        ret_code = subprocess.call(cmd, shell=True)

        if ret_code == 0:
            print("*", end="", flush=True)
            return None

        tries -= 1
        sleep(MODPACK_TIME_BETWEEN_RETRIES)

    print("-", end="", flush=True)
    return mod_id


def modpack_dependencies(mod_id, cfg):
    """
    Get all dependencies of a mod.

    Args:
        mod_id (int): The mod ID.
        cfg (dict): The config dictionary.

    Returns:
        A set of mod IDs.
    """
    try:
        deps = mod_dependencies(mod_id, cfg)
        print("*", end="", flush=True)
        return deps
    except ValueError:
        print(f"\n- Failed to get dependencies for mod {mod_id}.",
              end="", flush=True)
        return {-1}


def compatible_file(mod_id, cfg):
    """
    Get the latest compatible file of a mod.

    Args:
        mod_id (int): The mod ID.
        cfg (dict): The config dictionary.

    Returns:
        The file dictionary.

    Raises:
        IndexError: If the file has no gameVersions.
        ValueError: If the request times out or is malformed.
    """
    def _files(mod_id, index=0):
        """
        Get a list of files of a mod.

        Args:
            mod_id (int): The mod ID.
            index (int): The index of the first file to get.

        Returns:
            A list of file dictionaries.
        """
        end_point = BASE_URL + \
            f"/v1/mods/{mod_id}/files?index={index}&pageSize=50"
        headers = {"Accept": "application/json", "x-api-key": cfg["API_KEY"]}

        try:
            response = requests.get(end_point, headers=headers, timeout=5)
            response_data = response.json()["data"]

        except requests.exceptions.ReadTimeout:
            raise ValueError("Connection timed out.")

        except json.decoder.JSONDecodeError:
            raise ValueError("JSON lookup failed.")

        return response_data

# def compatible_file(mod_id, cfg):

    compatible_config = {cfg["minecraft_version"], cfg["loader"]}

    for i in range(0, 5000, 50):
        try:
            response = _files(mod_id, index=i)
            if not response:
                break
        except requests.exceptions.ReadTimeout:
            break
        except ValueError:
            break

        for file in response:
            if compatible_config <= set(file["gameVersions"]):
                return file

    return "Not found"


def mod_download_link(mod_id, cfg):
    """
    Get the download link of a mod.

    Args:
        mod_id (int): The mod ID.
        cfg (dict): The config dictionary.

    Returns:
        The download link.

    Raises:
        IndexError: If the file has no downloadUrl.
    """
    try:
        file = compatible_file(mod_id, cfg)
        download_url = file["downloadUrl"]
        if download_url:
            return download_url.replace(" ", "%20")
        return "Unavailable through API"

    except IndexError:
        return "Not found"

    except ValueError:
        return "Not found"

    except TypeError:
        return "Not found"


def mod_dependencies(mod_id, cfg):
    """
    Get all dependencies of a mod.

    Args:
        mod_id (int): The mod ID.
        cfg (dict): The config dictionary.

    Returns:
        A set of mod IDs.

    Raises:
        IndexError: If the file has no modId or relationType.
        ValueError: If the mod has no dependencies.
    """
    tries = MODPACK_DOWNLOAD_RETRIES
    while tries > 0:

        file = compatible_file(mod_id, cfg)

        if "dependencies" in file:

            ids = [d["modId"]
                   for d
                   in file["dependencies"]
                   if d["relationType"] == 3]

            ids = {int(d)
                   for d
                   in ids}

            return ids

        tries -= 1
        sleep(MODPACK_TIME_BETWEEN_RETRIES)

    raise ValueError("Failed to get dependencies.")


def is_integer(string):
    """
    Check if a string is an integer.

    Args:
        string (str): The string to check.

    Returns:
        True if the string is an integer, otherwise False.
    """
    try:
        int(string)
        return True
    except ValueError:
        return False


def fix_length(text, length=32, *, pad=True):
    """
    Fix the length of a string.

    Args:
        text (str): The string to fix.
        length (int): The length to fix the string to.

    Returns:
        The fixed string.

    Raises:
        IndexError: If the length is less than 3.
    """
    # Remove all emojis from the text
    text = text.encode('ascii', 'ignore').decode('ascii')

    output = text[:length - 3] + "..." if len(text) > length else text

    if pad:
        output = output.ljust(length)

    return output


def max_length_names(offset=59):
    """
    Get the maximum length of the names column.

    Args:
        offset (int): The offset of the names column.

    Returns:
        The maximum length of the names column.
    """
    return TERM_WIDTH - offset


def table_too_wide(table, terminal_width):
    """
    Check if a table is too wide for the terminal.

    Args:
        table (PrettyTable): The table to check.
        terminal_width (int): The width of the terminal.

    Returns:
        True if the table is too wide, otherwise False.
    """
    max_line_length = max(len(line)
                          for line
                          in str(table).split("\n"))

    return max_line_length > terminal_width


def main() -> int:
    """
    Main function
    """

    def _config():

        def __config():

            # Presence of the config file
            try:
                with open(CONFIG_PATH, "r") as file:
                    cfg = json.load(file)

            except OSError:
                raise ValueError("Config file is corrupted or missing.")

            # Presence of the keys
            if "API_KEY" not in cfg:
                raise ValueError("API_KEY not found in config file.")

            if "mods_path" not in cfg:
                raise ValueError("mods_path not found in config file.")

            if "minecraft_version" not in cfg:
                raise ValueError("minecraft_version not found in config file.")

            if "loader" not in cfg:
                raise ValueError("loader not found in config file.")

            # Validity of the values
            if not os.path.isdir(cfg["mods_path"].strip()):
                try:
                    os.makedirs(cfg["mods_path"].strip())
                except OSError:
                    raise ValueError("Invalid mods_path.")

            if cfg["loader"].strip() not in ["Fabric", "Forge"]:
                raise ValueError("Invalid loader. Valid values: Fabric, Forge")

            response = requests.get(f'{BASE_URL}/v1/games/432',
                                    headers={'Accept': 'application/json',
                                             'x-api-key': cfg['API_KEY']})

            if response.status_code != 200:
                raise ValueError("Invalid API_KEY.")

            return cfg

    # def _config():
        while True:

            try:
                cfg = __config()
                break

            except ValueError:

                api_link = "https://console.curseforge.com/?#/signup"

                print()
                print("Oops, your config file is missing or invalid!")
                print("I'll help you fix it...")
                print()
                print(f"Visit {api_link} to get an API key.")
                print()
                field_0 = input(" " * 4 + "What is your API key?: ")
                field_1 = input(" " * 4 + "Where is your mods folder? "
                                "(~/.minecraft/mods): ")
                field_2 = input(" " * 4 + "What is your Minecraft version?: ")
                field_3 = input(" " * 4 + "Are you using Forge or Fabric?: ")
                print()
                print("Saving and testing configuration...")
                print()

                # Expand user. If path is empty, write default
                if field_1.strip() == "":
                    field_1 = "~/.minecraft/mods"
                field_1 = os.path.expanduser(field_1)

                # Mod loader should be capitalized
                field_3 = field_3.capitalize()

                cfg = {"API_KEY": field_0,
                       "mods_path": field_1,
                       "minecraft_version": field_2,
                       "loader": field_3}

                os.makedirs("/".join(CONFIG_PATH.split("/")[:-1]),
                            exist_ok=True)

                with open(CONFIG_PATH, "w") as file:
                    json.dump(cfg, file, indent=4)

        return cfg

    def _updated_mods(cfg, table):

        def __updated_mods(cfg,
                           game_id=432,
                           min_downloads=1_000_000,
                           max_results=TERM_HEIGHT - 7):

            mods = []
            for iteration in range(0, 5000, 50):

                # Make request
                try:
                    end_point = f"{BASE_URL}/v1/mods/search"
                    end_point += f"?gameId={game_id}"
                    end_point += f"&gameVersion={cfg['minecraft_version']}"
                    end_point += f"&modLoaderType={cfg['loader']}"
                    end_point += "&sortField=3"
                    end_point += "&sortOrder=desc"
                    end_point += f"&index={iteration}"
                    end_point += "&pageSize=50"
                    headers = {"Accept": "application/json",
                               "x-api-key": cfg["API_KEY"]}
                    response = requests.get(end_point, headers=headers)
                    if not response:
                        break
                    response = response.json()["data"]

                except requests.exceptions.ReadTimeout:
                    break
                except ValueError:
                    break

                # Process response
                for mod in response:
                    if int(mod['downloadCount']) > min_downloads:
                        if len(mods) < max_results:
                            mods.append(mod)
                        else:
                            return mods

            return mods

        table.field_names = ["Id", "Author", "Name", "Downloads", "Updated"]

        fields = __updated_mods(cfg)

        fields = sorted(fields,
                        key=lambda x: x["dateModified"],
                        reverse=True)

        for field in fields:
            date = field["dateModified"]
            date = f"{date[5:7]}/{date[8:10]} {date[11:13]}:{date[14:16]}"
            row = [fix_length(str(field["id"]), 6),
                   fix_length(field["authors"][0]["name"], 16),
                   fix_length(field["name"], max_length_names()),
                   fix_length(numerize(field["downloadCount"]), 10),
                   fix_length(date, 11)]
            table.add_row(row)

    def _modpack(cfg, modpack_file):

        def __mod_name(mod_id):

            end_point = BASE_URL + f"/v1/mods/{mod_id}"
            headers = {"Accept": "application/json",
                       "x-api-key": cfg["API_KEY"]}

            try:
                response = requests.get(end_point, headers=headers)
                response_data = response.json()["data"]

            except requests.exceptions.ReadTimeout:
                return "ERROR: Connection timed out!"

            except json.decoder.JSONDecodeError:
                return "Unknown mod"

            return response_data["name"]

        errors = []
        wipe_line = "\x1b[2K\r"

        print()
        print("Warning! This will erase your mods folder!")
        print("Press ENTER to continue, CTRL+C to cancel.")
        input()

        # Save list of installed mods to ./logs/timestamp.log
        os.makedirs(f"{cfg['mods_path']}/logs", exist_ok=True)
        log_filename = f"{cfg['mods_path']}/logs/{int(time())}.log"
        mod_list = sorted(os.listdir(cfg["mods_path"]), key=str.lower)
        mod_list = [mod for mod in mod_list if mod.strip() != "logs"]

        try:
            with open(log_filename, "w") as file:
                file.write("\n".join(mod_list))

        except OSError:
            print("There was an error writing the log file.")
            return 2

        # Open modpack file and classify its lines
        try:
            with open(modpack_file, "r") as file:
                file_lines = file.read().strip().splitlines()

                comms = [line[1:].strip()
                         for line
                         in file_lines
                         if line.startswith("$")]

                lines = [line
                         for line
                         in file_lines
                         if line.strip()
                         and not line.lstrip().startswith("#")
                         and not line.lstrip().startswith("$")]

                mod_ids = {int(line.strip().split(" ")[0])
                           for line
                           in lines}

        except OSError:
            print("There was an error opening the modpack file.")
            return 1

        # Calculate dependencies
        print("Calculating dependencies...")
        with multiprocessing.Pool(processes=MODPACK_DOWNLOAD_THREADS) as pool:
            dep_ids = pool.starmap(modpack_dependencies,
                                   zip(mod_ids, repeat(cfg)))
        dep_ids = {dep_id
                   for sublist
                   in dep_ids
                   for dep_id
                   in sublist}

        if -1 in dep_ids:
            print("\n")
            print(f"Build FAILED "
                  f"for {cfg['minecraft_version']} {cfg['loader']}!")
            print(f"Configs file: {CONFIG_PATH}")
            print(f"Modpack file: {modpack_file}")
            print()
            return 4

        print(f"{wipe_line}Done!", end="")

        # Avoid repeated downloads
        dep_ids = dep_ids.difference(mod_ids)

        # Clear mods folder
        os.system(f"rm {cfg['mods_path']}/*" + " > /dev/null 2>&1")

        # Download mods
        print("\n\nDownloading mods...")
        with multiprocessing.Pool(processes=MODPACK_DOWNLOAD_THREADS) as pool:
            errors += pool.starmap(modpack_mod, zip(mod_ids, repeat(cfg)))
        print(f"{wipe_line}Done!", end="")

        # Download dependencies
        print("\n\nDownloading dependencies...")
        with multiprocessing.Pool(processes=MODPACK_DOWNLOAD_THREADS) as pool:
            errors += pool.starmap(modpack_mod, zip(dep_ids, repeat(cfg)))
        print(f"{wipe_line}Done!", end="")

        # Run custom commands
        print("\n")
        if comms:
            print("Running custom commands...")
            for command in comms:
                print("*", end="", flush=True)
                process = subprocess.run(["/bin/sh", "-c", command],
                                         stdout=subprocess.DEVNULL,
                                         stderr=subprocess.DEVNULL)
                exit_code = process.returncode
                if exit_code != 0:
                    print(f"\n\n{command}")
                    print(f" ⌙ Command failed with exit code: {exit_code}\n")
            print(f"{wipe_line}Done!", end="")

        # Print errors
        errors = [error
                  for error
                  in errors
                  if error is not None]

        if errors:
            print("\n\nThe following downloads failed:")
            for error_id in errors:
                print(f"{error_id} | {__mod_name(error_id)}")
            print()
            return 3

        print("\n")
        return 0

    def _mod_details(keyword, cfg, table):

        def __mod(mod_id):

            end_point = BASE_URL + f"/v1/mods/{mod_id}"
            headers = {"Accept": "application/json",
                       "x-api-key": cfg["API_KEY"]}

            try:
                response = requests.get(end_point, headers=headers)
                response_data = response.json()["data"]

            except requests.exceptions.ReadTimeout:
                return "ERROR: Connection timed out!"

            except json.decoder.JSONDecodeError:
                return "Unknown mod"

            return response_data

        field = __mod(keyword)
        if field == "Unknown mod":
            return

        # Set the title of the table
        date = field['dateModified'][0:10]
        title = ""
        title += f"{fix_length(str(field['id']), 6)} | "
        title += f"{fix_length(field['authors'][0]['name'], 16)} | "
        title += f"{fix_length(field['name'], max_length_names())} | "
        title += f"{fix_length(numerize(field['downloadCount']), 10)} | "
        title += f"{fix_length(date, 11)}"

        # t += f"Updated: {field['dateModified'][0:10]}"
        table.field_names = [title]

        # The second row shows a summary followed by the mod download link
        table.add_row([field["links"]["websiteUrl"]])
        table.add_row([fix_length(field["summary"].strip(),
                                  max_length_names(4))])
        table.add_row([""])
        table.add_row(
            [f"Download ({cfg['minecraft_version']} {cfg['loader']}):"])
        table.add_row([mod_download_link(field["id"], cfg)])

        # The last row holds the download links for the dependencies
        try:
            dependencies = mod_dependencies(field["id"], cfg)

        except ValueError:
            return

        except IndexError:
            return

        if not dependencies:
            return

        table.add_row([""])
        table.add_row(["Required dependencies:"])

        for dep_id in dependencies:
            url = mod_download_link(dep_id, cfg)
            table.add_row([f"{dep_id} | {url}"])

    def _search_mods(keyword, cfg, table):

        def __search_mods(cfg,
                          game_id=432,
                          keyword=None):

            end_point = BASE_URL + f"/v1/mods/search?gameId={game_id}"
            if keyword:
                end_point += f"&searchFilter={keyword}"
            if cfg["minecraft_version"]:
                end_point += f"&gameVersion={cfg['minecraft_version']}"
            if cfg["loader"]:
                end_point += f"&modLoaderType={cfg['loader']}"

            headers = {"Accept": "application/json",
                       "x-api-key": cfg["API_KEY"]}

            response = requests.get(end_point, headers=headers)

            return response.json()["data"]

        # Set the title of the table
        table.field_names = ["Id", "Author", "Name", "Downloads", "Updated"]

        fields = __search_mods(cfg, keyword=keyword)

        for field in sorted(fields, key=lambda x: x["downloadCount"],
                            reverse=True):

            # Add a row for each result (mod)
            table.add_row([fix_length(str(field["id"]), 6),
                           fix_length(field["authors"][0]["name"], 16),
                           fix_length(field["name"], max_length_names()),
                           fix_length(numerize(field["downloadCount"]), 10),
                           fix_length(field["dateModified"][0:10], 11)])

    def _table():
        table = PrettyTable()
        table.align = "l"
        table.set_style(SINGLE_BORDER)
        return table

# def main():
    try:
        keyword = " ".join(sys.argv[1:])
    except IndexError:
        keyword = ""

    cfg = _config()
    table = _table()

    # ./cursely
    if keyword == "":
        print("Recently updated mods with more than 1M downloads:")
        _updated_mods(cfg, table)

    # ./cursely modpack.txt
    elif os.path.isfile(keyword):
        _modpack(cfg, keyword)
        return 0

    # ./cursely 123456
    elif is_integer(keyword):
        _mod_details(keyword, cfg, table)

    # ./cursely keyword
    elif keyword.strip() not in {"-h", "--help"}:
        print(f"Search results for '{keyword}':")
        _search_mods(keyword, cfg, table)

    # ./cursely -h or ./cursely --help
    else:
        print(USAGE_INFO)
        return 0

    if not table._rows:
        print("\nNo results found.\n")
        return 0

    if TERM_WIDTH < 62 or table_too_wide(table, TERM_WIDTH):
        print()
        print("Not enough space to display results!".center(TERM_WIDTH))
        print()
        return 0

    print(table, flush=True)


if __name__ == "__main__":
    try:
        main()
    except requests.exceptions.ConnectionError:
        print("\nUnable to connect to the internet.\n")
    except KeyboardInterrupt:
        print("\n\nAborted.\n")

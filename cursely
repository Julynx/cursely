#!/usr/bin/env python3

"""
@file     cursely
@date     04/05/2023
@author   Julio Cabria
"""

import sys
import os
import json
import subprocess
import multiprocessing
from itertools import repeat
from time import sleep
import requests
from prettytable import PrettyTable, SINGLE_BORDER
from numerize.numerize import numerize

BASE_URL = "https://api.curseforge.com"
CONFIG_PATH = os.path.expanduser("~/.config/cursely/config.json")

TERM_WIDTH = os.get_terminal_size().columns
MODPACK_DOWNLOAD_THREADS = os.cpu_count() * 2
MODPACK_DOWNLOAD_RETRIES = 3
MODPACK_TIME_BETWEEN_RETRIES = 1


USAGE_INFO = """
Usage:
    cursely             Browse popular recently updated mods.
    cursely [MOD_ID]    Get a brief description of a mod and its download link.
    cursely [KEYWORD]   Search a mod by its name or author.
    cursely [MODPACK]   Install all listed mods and their dependencies.
    cursely --help      Show this help message.
"""


def modpack_mod(mod_id, cfg):
    """
    Download a mod.

    Args:
        mod_id (int): The mod ID.
        cfg (dict): The config dictionary.

    Returns:
        None if the mod was downloaded successfully, otherwise the mod ID.
    """
    tries = MODPACK_DOWNLOAD_RETRIES
    while tries > 0:

        url = mod_download_link(mod_id, cfg)

        cmd = f"wget -P '{cfg['mods_path']}' '{url}' > /dev/null 2>&1"
        ret_code = subprocess.call(cmd, shell=True)

        if ret_code == 0:
            print("*", end="", flush=True)
            return None

        tries -= 1
        sleep(MODPACK_TIME_BETWEEN_RETRIES)

    print("-", end="", flush=True)
    return mod_id


def modpack_dependencies(mod_id, cfg):
    """
    Get all dependencies of a mod.

    Args:
        mod_id (int): The mod ID.
        cfg (dict): The config dictionary.

    Returns:
        A set of mod IDs.
    """
    try:
        deps = mod_dependencies(mod_id, cfg)
        print("*", end="", flush=True)
        return deps
    except ValueError:
        print("-", end="", flush=True)
        return {-1}


def compatible_file(mod_id, cfg):
    """
    Get the latest compatible file of a mod.

    Args:
        mod_id (int): The mod ID.
        cfg (dict): The config dictionary.

    Returns:
        The file dictionary.
    """
    def _files(mod_id, index=0):
        """
        Get a list of files of a mod.

        Args:
            mod_id (int): The mod ID.
            index (int): The index of the first file to get.

        Returns:
            A list of file dictionaries.
        """
        end_point = BASE_URL + \
            f"/v1/mods/{mod_id}/files?index={index}&pageSize=50"
        headers = {"Accept": "application/json", "x-api-key": cfg["API_KEY"]}

        try:
            response = requests.get(end_point, headers=headers, timeout=5)
            response_data = response.json()["data"]

        except requests.exceptions.ReadTimeout:
            raise ValueError("Connection timed out")

        except json.decoder.JSONDecodeError:
            raise ValueError("File lookup failed")

        return response_data

# def compatible_file(mod_id, cfg):

    compatible_config = {cfg["minecraft_version"], cfg["loader"]}

    for i in range(0, 5000, 50):
        try:
            response = _files(mod_id, index=i)
            if not response:
                break
        except requests.exceptions.ReadTimeout:
            break
        except ValueError:
            break

        for file in response:
            if compatible_config <= set(file["gameVersions"]):
                return file

    return "Not found"


def mod_download_link(mod_id, cfg):
    """
    Get the download link of a mod.

    Args:
        mod_id (int): The mod ID.
        cfg (dict): The config dictionary.

    Returns:
        The download link.
    """
    try:
        file = compatible_file(mod_id, cfg)
        return file["downloadUrl"]

    except (ValueError, TypeError, KeyError):
        return "Not found"


def mod_dependencies(mod_id, cfg):
    """
    Get all dependencies of a mod.

    Args:
        mod_id (int): The mod ID.
        cfg (dict): The config dictionary.

    Returns:
        A set of mod IDs.
    """
    tries = MODPACK_DOWNLOAD_RETRIES
    while tries > 0:

        file = compatible_file(mod_id, cfg)

        if "dependencies" in file:

            ids = [d["modId"]
                   for d
                   in file["dependencies"]
                   if d["relationType"] == 3]

            ids = {int(d)
                   for d
                   in ids}

            return ids

        tries -= 1
        sleep(MODPACK_TIME_BETWEEN_RETRIES)

    raise ValueError("Failed to get dependencies")


def is_integer(string):
    """
    Check if a string is an integer.

    Args:
        string (str): The string to check.

    Returns:
        True if the string is an integer, otherwise False.
    """
    try:
        int(string)
        return True
    except ValueError:
        return False


def fix_length(text, length=32, *, pad=True):
    """
    Fix the length of a string.

    Args:
        text (str): The string to fix.
        length (int): The length to fix the string to.

    Returns:
        The fixed string.
    """
    # Remove all emojis from the text
    text = text.encode('ascii', 'ignore').decode('ascii')

    output = text[:length-3] + "..." if len(text) > length else text

    if pad:
        output = output.ljust(length)

    return output


def max_length_names(offset=59):
    """
    Get the maximum length of the names column.

    Args:
        offset (int): The offset of the names column.

    Returns:
        The maximum length of the names column.
    """
    return TERM_WIDTH - offset


def table_too_wide(table, terminal_width):
    """
    Check if a table is too wide for the terminal.

    Args:
        table (PrettyTable): The table to check.
        terminal_width (int): The width of the terminal.

    Returns:
        True if the table is too wide, otherwise False.
    """
    max_line_length = max(len(line)
                          for line
                          in str(table).split("\n"))

    return max_line_length > terminal_width


def main() -> int:
    """
    Main function
    """

    def _config():

        def __config():

            # Presence of the config file
            if not os.path.isfile(CONFIG_PATH):
                raise ValueError("Config file not found")

            with open(CONFIG_PATH, "r") as f:
                cfg = json.load(f)

            # Presence of the keys
            if "API_KEY" not in cfg:
                raise ValueError("API_KEY not found in config file")

            if "mods_path" not in cfg:
                raise ValueError("mods_path not found in config file")

            if "minecraft_version" not in cfg:
                raise ValueError("minecraft_version not found in config file")

            if "loader" not in cfg:
                raise ValueError("loader not found in config file")

            # Validity of the values
            if not os.path.isdir(cfg["mods_path"].strip()):
                raise ValueError(
                    f"The specified mods_path is invalid [{cfg['mods_path']}]")

            if cfg["loader"].strip() not in ["Fabric", "Forge"]:
                raise ValueError("Invalid loader. Valid values: Fabric, Forge")

            r = requests.get(f'{BASE_URL}/v1/games/432',
                             headers={'Accept': 'application/json',
                                      'x-api-key': cfg['API_KEY']})

            if r.status_code != 200:
                raise ValueError("Invalid API_KEY")

            return cfg

    # def _config():
        while True:

            try:
                cfg = __config()
                break

            except ValueError:

                api_link = "https://console.curseforge.com/?#/signup"

                print()
                print("Oops, your config file is missing or invalid!")
                print("I'll help you fix it...")
                print()
                print(f"Visit {api_link} to get an API key.")
                print()
                f0 = input(" "*4 + "What is your API key?: ")
                f1 = input(" "*4 + "Where is your mods folder? "
                           "(~/.minecraft/mods): ")
                f2 = input(" "*4 + "What is your Minecraft version?: ")
                f3 = input(" "*4 + "Are you using Forge or Fabric?: ")
                print()
                print("Saving and testing configuration...")
                print()

                # Expand user. If path is empty, write default
                if f1.strip() == "":
                    f1 = "~/.minecraft/mods"
                f1 = os.path.expanduser(f1)

                # Mod loader should be capitalized
                f3 = f3.capitalize()

                cfg = {"API_KEY": f0,
                       "mods_path": f1,
                       "minecraft_version": f2,
                       "loader": f3}

                os.makedirs("/".join(CONFIG_PATH.split("/")[:-1]),
                            exist_ok=True)

                with open(CONFIG_PATH, "w") as f:
                    json.dump(cfg, f, indent=4)

        return cfg

    def _updated_mods(cfg, x):

        def __updated_mods(cfg,
                           game_id=432,
                           min_downloads=1_000_000,
                           max_results=24):

            mods = []
            for i in range(0, 5000, 50):

                # Make request
                try:
                    end_point = f"{BASE_URL}/v1/mods/search"
                    end_point += f"?gameId={game_id}"
                    end_point += f"&gameVersion={cfg['minecraft_version']}"
                    end_point += f"&modLoaderType={cfg['loader']}"
                    end_point += "&sortField=3"
                    end_point += "&sortOrder=desc"
                    end_point += f"&index={i}"
                    end_point += "&pageSize=50"
                    headers = {"Accept": "application/json",
                               "x-api-key": cfg["API_KEY"]}
                    response = requests.get(end_point, headers=headers)
                    if not response:
                        break
                    response = response.json()["data"]

                except requests.exceptions.ReadTimeout:
                    break
                except ValueError:
                    break

                # Process response
                for mod in response:
                    if int(mod['downloadCount']) > min_downloads:
                        if len(mods) < max_results:
                            mods.append(mod)
                        else:
                            return mods

            return mods

        x.field_names = ["Id", "Author", "Name", "Downloads", "Updated"]

        fields = __updated_mods(cfg)

        fields = sorted(fields,
                        key=lambda x: x["dateModified"],
                        reverse=True)

        for field in fields:
            date = field["dateModified"]
            date = f"{date[5:7]}/{date[8:10]} {date[11:13]}:{date[14:16]}"
            row = [fix_length(str(field["id"]), 6),
                   fix_length(field["authors"][0]["name"], 16),
                   fix_length(field["name"], max_length_names()),
                   fix_length(numerize(field["downloadCount"]), 10),
                   fix_length(date, 11)]
            x.add_row(row)

    def _modpack(cfg, modpack_file):

        def __mod_name(mod_id):

            end_point = BASE_URL + f"/v1/mods/{mod_id}"
            headers = {"Accept": "application/json",
                       "x-api-key": cfg["API_KEY"]}

            try:
                response = requests.get(end_point, headers=headers)
                response_data = response.json()["data"]

            except requests.exceptions.ReadTimeout:
                return "ERROR: Connection timed out!"

            except json.decoder.JSONDecodeError:
                return "Unknown mod"

            return response_data["name"]

        errors = []
        wipe_line = "\x1b[2K\r"

        print()
        print("Warning! This will wipe your mods folder!")
        print("Press ENTER to continue, CTRL+C to cancel")
        input()

        # Clear mods folder
        os.system(f"rm {cfg['mods_path']}/*" + " > /dev/null 2>&1")

        # Open modpack file and classify its lines
        with open(modpack_file, "r") as f:
            file = f.read().strip().splitlines()

            comms = [line[1:].strip()
                     for line
                     in file
                     if line.startswith("$")]

            lines = [line
                     for line
                     in file
                     if not line.strip() == ""]

            lines = [line
                     for line
                     in lines
                     if not line.startswith("#")]

            lines = [line
                     for line
                     in lines
                     if not line.startswith("$")]

            mod_ids = {int(l.strip().split(" ")[0])
                       for l
                       in lines}

        # Calculate dependencies
        print("Calculating dependencies...")
        with multiprocessing.Pool(processes=MODPACK_DOWNLOAD_THREADS) as pool:
            dep_ids = pool.starmap(modpack_dependencies,
                                   zip(mod_ids, repeat(cfg)))
        dep_ids = {dep_id
                   for sublist
                   in dep_ids
                   for dep_id
                   in sublist}

        print(f"{wipe_line}Done!", end="")

        if -1 in dep_ids:
            print("\n")
            print("Unable to obtain mod dependencies.")
            print("Please try again later.")
            print()
            return

        # Avoid repeated downloads
        dep_ids = dep_ids.difference(mod_ids)

        # Download mods
        print("\n\nDownloading mods...")
        with multiprocessing.Pool(processes=MODPACK_DOWNLOAD_THREADS) as pool:
            errors += pool.starmap(modpack_mod, zip(mod_ids, repeat(cfg)))
        print(f"{wipe_line}Done!", end="")

        # Download dependencies
        print("\n\nDownloading dependencies...")
        with multiprocessing.Pool(processes=MODPACK_DOWNLOAD_THREADS) as pool:
            errors += pool.starmap(modpack_mod, zip(dep_ids, repeat(cfg)))
        print(f"{wipe_line}Done!", end="")

        # Run custom commands
        print("\n")
        if comms:
            print("Running custom commands...")
            for command in comms:
                print("*", end="", flush=True)
                process = subprocess.run(["/bin/sh", "-c", command],
                                         stdout=subprocess.DEVNULL,
                                         stderr=subprocess.DEVNULL)
                exit_code = process.returncode
                if exit_code != 0:
                    print(f"\n\n{command}")
                    print(f" ⌙ Command failed with exit code: {exit_code}\n")
            print(f"{wipe_line}Done!", end="")

        # Print errors
        errors = [e
                  for e
                  in errors
                  if e is not None]

        if errors:
            print("\n\nThe following downloads failed:")
            for error_id in errors:
                print(f"{error_id} | {__mod_name(error_id)}")
            print()
        else:
            print("\n")

    def _mod_details(keyword, cfg, x):

        def __mod(mod_id):

            end_point = BASE_URL + f"/v1/mods/{mod_id}"
            headers = {"Accept": "application/json",
                       "x-api-key": cfg["API_KEY"]}

            try:
                response = requests.get(end_point, headers=headers)
                response_data = response.json()["data"]

            except requests.exceptions.ReadTimeout:
                return "ERROR: Connection timed out!"

            except json.decoder.JSONDecodeError:
                return "Unknown mod"

            return response_data

        field = __mod(keyword)
        if field == "Unknown mod":
            return

        # Set the title of the table
        date = field['dateModified'][0:10]
        t = ""
        t += f"{fix_length(str(field['id']), 6)} | "
        t += f"{fix_length(field['authors'][0]['name'], 16)} | "
        t += f"{fix_length(field['name'], max_length_names())} | "
        t += f"{fix_length(numerize(field['downloadCount']), 10)} | "
        t += f"{fix_length(date, 11)}"

        # t += f"Updated: {field['dateModified'][0:10]}"
        x.field_names = [t]

        # The second row shows a summary followed by the mod download link
        x.add_row([field["links"]["websiteUrl"]])
        x.add_row([fix_length(field["summary"].strip(), max_length_names(4))])
        x.add_row([""])
        x.add_row([f"Download ({cfg['loader']} {cfg['minecraft_version']}):"])
        x.add_row([mod_download_link(field["id"], cfg)])

        # The last row holds the download links for the dependencies
        try:
            dependencies = mod_dependencies(field["id"], cfg)
        except ValueError:
            return

        if not dependencies:
            return

        x.add_row([""])
        x.add_row(["Required dependencies:"])

        for dep_id in dependencies:
            url = mod_download_link(dep_id, cfg)
            x.add_row([f"{dep_id} | {url}"])

    def _search_mods(keyword, cfg, x):

        def __search_mods(cfg,
                          game_id=432,
                          keyword=None):

            end_point = BASE_URL + f"/v1/mods/search?gameId={game_id}"
            if keyword:
                end_point += f"&searchFilter={keyword}"
            if cfg["minecraft_version"]:
                end_point += f"&gameVersion={cfg['minecraft_version']}"
            if cfg["loader"]:
                end_point += f"&modLoaderType={cfg['loader']}"

            headers = {"Accept": "application/json",
                       "x-api-key": cfg["API_KEY"]}

            response = requests.get(end_point, headers=headers)

            return response.json()["data"]

        # Set the title of the table
        x.field_names = ["Id", "Author", "Name", "Downloads", "Updated"]

        fields = __search_mods(cfg, keyword=keyword)

        for field in sorted(fields, key=lambda x: x["downloadCount"],
                            reverse=True):

            # Add a row for each result (mod)
            x.add_row([fix_length(str(field["id"]), 6),
                       fix_length(field["authors"][0]["name"], 16),
                       fix_length(field["name"], max_length_names()),
                       fix_length(numerize(field["downloadCount"]), 10),
                       fix_length(field["dateModified"][0:10], 11)])

    def _table():
        x = PrettyTable()
        x.align = "l"
        x.set_style(SINGLE_BORDER)
        return x

# def main():
    try:
        keyword = " ".join(sys.argv[1:])
    except IndexError:
        keyword = ""

    cfg = _config()
    x = _table()

    # ./cursely
    if keyword == "":
        print("Recently updated mods with more than 1M downloads:")
        _updated_mods(cfg, x)

    # ./cursely modpack.txt
    elif os.path.isfile(keyword):
        _modpack(cfg, keyword)
        return 0

    # ./cursely 123456
    elif is_integer(keyword):
        _mod_details(keyword, cfg, x)

    # ./cursely keyword
    elif keyword.strip() not in {"-h", "--help"}:
        print(f"Search results for '{keyword}':")
        _search_mods(keyword, cfg, x)

    # ./cursely -h or ./cursely --help
    else:
        print(USAGE_INFO)
        return 0

    if not x._rows:
        print("\nNo results found.\n")
        return 0

    if TERM_WIDTH < 62 or table_too_wide(x, TERM_WIDTH):
        print()
        print("Not enough space to display results!".center(TERM_WIDTH))
        print()
        return 0

    print(x, flush=True)


if __name__ == "__main__":
    try:
        main()
    except ConnectionError:
        print("\nUnable to connect to the internet\n")
    except KeyboardInterrupt:
        print("\n\nAborted\n")

#!/usr/bin/env python3

import os
import sys
import json
import shutil
from time import sleep
from multiprocessing import Pool
from itertools import chain, repeat
import subprocess
import requests
from prettytable import PrettyTable, SINGLE_BORDER
from numerize.numerize import numerize

DOWNLOAD_RETRIES = 2
HOME = os.path.expanduser("~")
CONFIG_FOLDER = os.path.join(HOME, ".config", "cursely")
CONFIG_PATH = os.path.join(CONFIG_FOLDER, "config.json")

USAGE_INFO = f"""
Usage:
    cursely [MOD_ID]    Get a brief description of a mod and its download link.
    cursely [KEYWORD]   Search for a mod by its name or author.
    cursely [MODPACK]   Install all listed mods and their dependencies.
    cursely --help      Show this help message.

Your configuration (minecraft version, loader, mods path, etc.) is usually
stored in '{CONFIG_PATH}'. If you ever need to modify it,
simply delete the file and run cursely again or edit the file directly.

If you are running cursely for the first time, you do not need to manually
create a configuration file. It will ask you to provide the necessary
information and create the file for you.
"""

if sys.platform == "linux":
    SHELL_PATH = "/bin/sh"
    SHELL_ARGS = "-c"
    DEF_MODS_PATH = os.path.join(HOME, ".minecraft", "mods")
elif sys.platform == "win32":
    SHELL_PATH = "cmd"
    SHELL_ARGS = "/c"
    DEF_MODS_PATH = os.path.join(HOME, "AppData", "Roaming",
                                 ".minecraft", "mods")


def Mod(mod_id, cfg):
    """
    Factory function for Mod objects.

    Args:
        mod_id (int or str): The ID of the mod or the URL to the mod.
        cfg (dict): The config file as a dictionary object.

    Returns:
        Mod (CurseforgeMod or ModrinthMod): The mod object.
    """
    try:
        int(mod_id)
        return CurseforgeMod(mod_id, cfg)
    except (ValueError, TypeError):
        return ModrinthMod(mod_id, cfg)


class CurseforgeMod:
    """
    A class to represent a mod from curseforge.com.
    """
    BASE_URL = "https://api.curseforge.com/v1"

    def __init__(self, mod_id, cfg):
        """
        Initialize a CurseforgeMod object.

        Args:
            mod_id (int): The ID of the mod.
            cfg (dict): The target config for the mod.
                        {"API_KEY": Your curseforge API key as a string,
                         "minecraft_version": The target minecraft version,
                         "loader": The target loader. ('Fabric' or 'Forge')
                         ...}
        """
        if id is None or cfg is None:
            raise ValueError("id and cfg must not be None.")

        self.mod_id = mod_id
        self.cfg = cfg
        self._name = None
        self._mod = None
        self._downloads = None
        self._last_updated = None
        self._file = None
        self._dependencies = None
        self._website = None
        self._summary = None
        self._url = None

    def __eq__(self, __value: object) -> bool:
        """
        Check if two CurseforgeMod objects are equal.

        Args:
            __value (object): The object to compare to.

        Returns:
            bool: True if the objects are equal, False otherwise.
        """
        if isinstance(__value, CurseforgeMod):
            return self.mod_id == __value.mod_id
        return False

    def __repr__(self) -> str:
        """
        String representation of a CurseforgeMod.

        Returns:
            str: The mod name if it is able to get it, else the mod id.
        """
        try:
            return str(self.name)
        except ValueError:
            return str(self.mod_id)

    def __hash__(self) -> int:
        """
        Get the hash of a CurseforgeMod object.

        Returns:
            int: The id of the mod.
        """
        return hash(self.mod_id)

    def _make_request(self, url_path, tries=DOWNLOAD_RETRIES):
        """
        Make a request to the curseforge API.

        Args:
            url_path (str): The url path to the resource.
            tries (int): The number of tries left.

        Returns:
            dict: The response as a json object.

        Raises:
            ValueError: If the request fails.
        """
        while tries > 0:

            end_point = f"{self.BASE_URL}{url_path}"
            headers = {"Accept": "application/json",
                       "x-api-key": self.cfg["API_KEY"]}

            try:
                response = requests.get(end_point, headers=headers, timeout=1)
                return response.json()["data"]

            except Exception:
                sleep(DOWNLOAD_RETRIES + 1 - tries)
                tries -= 1

        raise ValueError("Too many failed requests.")

    @property
    def name(self):
        """
        Get the name of a mod.

        Returns:
            str: The name of the mod.

        Raises:
            ValueError: If the name lookup fails.
        """
        if self._name is not None:
            return self._name

        self._name = self.mod["name"]
        return self._name

    @property
    def mod(self):
        """
        Get the mod object.

        Returns:
            dict: The mod as a json object.

        Raises:
            ValueError: If the connection fails.
        """
        if self._mod is not None:
            return self._mod

        url_path = f"/mods/{self.mod_id}"
        self._mod = self._make_request(url_path)
        return self._mod

    @property
    def downloads(self):
        """
        Get the number of downloads of a mod.

        Returns:
            int: The number of downloads.

        Raises:
            ValueError: If the connection fails.
        """
        if self._downloads is not None:
            return self._downloads

        self._downloads = self.mod["downloadCount"]
        return self._downloads

    @property
    def last_updated(self, crop_date=True):
        """
        Get the last update of a mod.

        Returns:
            str: The last update.

        Raises:
            ValueError: If the connection fails.
        """
        if self._last_updated is not None:
            return self._last_updated

        date = self.mod["dateModified"]
        if crop_date:
            date = date[:10]

        self._last_updated = date
        return self._last_updated

    @property
    def file(self):
        """
        Get the latest file of a mod that is compatible with the given config.

        Returns:
            dict: The file of the mod as a json object.

        Raises:
            ValueError: If the connection fails or if no compatible file
            is found.
        """

        def files(mod_id, index=0):
            """
            Get a list of files for a mod. Paginated with page size 50.

            Args:
                index (int): The index of the first file to be returned.

            returns:
                A list of files.

            Raises:
                ValueError: If the request fails.
            """
            url_path = f"/mods/{mod_id}/files?index={index}&pageSize=50"
            response = self._make_request(url_path)
            return response

        if self._file is not None:
            return self._file

        compatible_config = {self.cfg["minecraft_version"],
                             self.cfg["loader"]}

        max_results = 5000
        page_size = 50
        for i in range(0, max_results, page_size):
            try:
                response = files(self.mod_id, index=i)
                if not response:
                    break
            except ValueError:
                break

            for file in response:
                if compatible_config <= set(file["gameVersions"]):
                    self._file = file
                    return self._file

        raise ValueError("No compatible file found.")

    @property
    def dependencies(self):
        """
        Get all dependencies of a mod.

        Args:
            mod_id (int): The mod ID.
            cfg (dict): The config dictionary.

        Returns:
            A set of mod IDs.

        Raises:
            IndexError: If the file has no modId or relationType.
            ValueError: If the mod has no dependencies.
        """
        if self._dependencies is not None:
            return self._dependencies

        dependencies = {CurseforgeMod(dependency["modId"], self.cfg)
                        for dependency
                        in self.file["dependencies"]
                        if dependency["modId"] is not None
                        and dependency["relationType"] == 3}

        self._dependencies = dependencies
        return self._dependencies

    @property
    def website(self):
        if self._website is not None:
            return self._website

        self._website = self.mod["links"]["websiteUrl"]
        return self._website

    @property
    def summary(self):
        if self._summary is not None:
            return self._summary

        self._summary = self.mod["summary"]
        return self._summary.strip()

    @property
    def url(self):
        """
        Get the download URL of a mod.

        Returns:
            str: The download URL of the mod.

        Raises:
            ValueError: If the download URL is unavailable or
            the request fails.
        """
        if self._url is not None:
            return self._url

        download_url = self.file["downloadUrl"]
        if download_url:
            download_url = download_url.replace(" ", "%20")
            self._url = download_url
            return self._url

        raise ValueError("Unavailable through API")


class ModrinthMod:
    """
    A class representing a mod from modrinth.com.
    """
    BASE_URL = "https://api.modrinth.com/v2"
    USER_AGENT = "Cursely/testing2 (github.com/julynx/cursely)"

    def __init__(self, mod_id, cfg):
        """
        Initialize a ModrinthMod object.

        Args:
            id (int): The ID of the mod.
            cfg (dict): The target config for the mod.
                        {"API_KEY": Your curseforge API key as a string,
                         "minecraft_version": The target minecraft version,
                         "loader": The target loader. ('Fabric' or 'Forge')
                         ...}
        """
        if mod_id is None or cfg is None:
            raise ValueError("id and cfg must not be None.")

        self.mod_id = mod_id
        self.cfg = cfg
        self._name = None
        self._mod = None
        self._downloads = None
        self._last_updated = None
        self._latest_version = None
        self._file = None
        self._dependencies = None
        self._website = None
        self._summary = None
        self._url = None

    def __eq__(self, __value: object) -> bool:
        """
        Check if two ModrinthMod objects are equal.

        Args:
            __value (object): The object to compare to.

        Returns:
            bool: True if the objects are equal, False otherwise.
        """
        if isinstance(__value, ModrinthMod):
            return self.mod_id == __value.mod_id
        return False

    def __repr__(self) -> str:
        """
        String representation of a ModrinthMod.

        Returns:
            str: The mod name if it is able to get it, else the mod id.
        """
        try:
            return str(self.name)
        except ValueError:
            return str(self.mod_id)

    def __hash__(self) -> int:
        """
        Get the hash of a ModrinthMod object.

        Returns:
            int: The id of the mod.
        """
        return hash(self.mod_id)

    def _make_request(self, url_path, tries=DOWNLOAD_RETRIES):
        """
        Make a request to the modrinth API.

        Args:
            url_path (str): The url path to the endpoint.
            tries (int): The number of tries left.

        Returns:
            dict: The response as a json object.

        Raises:
            ValueError: If the request fails.
        """
        while tries > 0:

            end_point = f"{self.BASE_URL}{url_path}"
            headers = {"Accept": "application/json",
                       "User-Agent": self.USER_AGENT}

            try:
                response = requests.get(end_point, headers=headers, timeout=1)
                return response.json()

            except Exception:
                sleep(DOWNLOAD_RETRIES + 1 - tries)
                tries -= 1

        raise ValueError("Too many failed requests.")

    @property
    def name(self):
        """
        Get the name of a mod.

        Returns:
            str: The name of the mod.

        Raises:
            ValueError: If the name lookup fails.
        """
        if self._name is not None:
            return self._name

        self._name = self.mod["title"]
        return self._name

    @property
    def mod(self):
        """
        Get the mod object.

        Returns:
            dict: The mod as a json object.

        Raises:
            ValueError: If the connection fails.
        """
        if self._mod is not None:
            return self._mod

        url_path = f"/project/{self.mod_id}"
        self._mod = self._make_request(url_path)
        return self._mod

    @property
    def downloads(self):
        """
        Get the number of downloads of a mod.

        Returns:
            int: The number of downloads.

        Raises:
            ValueError: If the connection fails.
        """
        if self._downloads is not None:
            return self._downloads

        self._downloads = self.mod["downloads"]
        return self._downloads

    @property
    def last_updated(self, crop_date=True):
        """
        Get the last updated date of a mod.

        Returns:
            str: The last updated date.

        Raises:
            ValueError: If the connection fails.
        """
        if self._last_updated is not None:
            return self._last_updated

        date = self.mod["updated"]
        if crop_date:
            date = date[:10]

        self._last_updated = date
        return self._last_updated

    @property
    def latest_version(self):
        """
        Get the latest version of a mod compatible with the target config.

        Returns:
            dict: The latest version as a json object.

        Raises:
            ValueError: If no compatible version is found.
        """
        if self._latest_version is not None:
            return self._latest_version

        minecraft_version = self.cfg["minecraft_version"]
        mod_loader = self.cfg["loader"].lower()

        url_path = f"/project/{self.mod_id}/version"
        versions = self._make_request(url_path)

        try:
            version = next(version
                           for version
                           in versions
                           if minecraft_version in version["game_versions"]
                           and mod_loader in version["loaders"])
        except StopIteration:
            raise ValueError("No compatible version found.")

        self._latest_version = version
        return self._latest_version

    @property
    def file(self):
        """
        Get the latest file of a mod compatible with the target config.

        Returns:
            dict: The latest file as a json object.

        Raises:
            ValueError: If no compatible file is found.
        """
        if self._file is not None:
            return self._file

        try:
            version_file = next(file
                                for file
                                in self.latest_version["files"]
                                if file["primary"])

        except StopIteration:
            raise ValueError("No compatible file found.")

        self._file = version_file
        return self._file

    @property
    def dependencies(self):
        """
        Get the dependencies of a mod.

        Returns:
            set: The dependencies as a set of ModrinthMod objects.
        """
        if self._dependencies is not None:
            return self._dependencies

        self._dependencies = {ModrinthMod(dependency["project_id"], self.cfg)
                              for dependency
                              in self.latest_version["dependencies"]
                              if dependency["project_id"] is not None
                              and dependency["dependency_type"] == "required"}

        return self._dependencies

    @property
    def website(self):
        if self._website is not None:
            return self._website

        self._website = f"https://modrinth.com/mod/{self.mod['slug']}"
        return self._website

    @property
    def summary(self):
        if self._summary is not None:
            return self._summary

        self._summary = self.mod["description"]
        return self._summary.strip()

    @property
    def url(self):
        """
        Get the download url of a mod.

        Returns:
            str: The download url.

        Raises:
            ValueError: If the download url lookup fails.
        """
        if self._url is not None:
            return self._url

        download_url = self.file["url"]
        if not download_url:
            raise ValueError("Unavailable through API")

        self._url = download_url
        return self._url


class CurseforgeSearch():

    BASE_URL = "https://api.curseforge.com/v1"

    def __init__(self, keyword, cfg) -> None:
        self.keyword = keyword
        self.cfg = cfg
        self.results = []
        self._search()

    def __iter__(self):
        return self

    def __next__(self):
        return next(self.results)

    def _make_request(self, url_path, params=None, tries=DOWNLOAD_RETRIES):
        """
        Make a request to the curseforge API.

        Args:
            url_path (str): The url path to the resource.
            tries (int): The number of tries left.

        Returns:
            dict: The response as a json object.

        Raises:
            ValueError: If the request fails.
        """
        while tries > 0:

            end_point = f"{self.BASE_URL}{url_path}"
            headers = {"Accept": "application/json",
                       "x-api-key": self.cfg["API_KEY"]}

            try:
                response = requests.get(end_point,
                                        params=params,
                                        headers=headers,
                                        timeout=1)
                return response.json()["data"]

            except Exception:
                sleep(DOWNLOAD_RETRIES + 1 - tries)
                tries -= 1

        raise ValueError("Too many failed requests.")

    def _search(self):

        if self.results != []:
            return self.results

        url_path = "/mods/search"
        params = {'gameId': 432,
                  'searchFilter': self.keyword,
                  'gameVersion': self.cfg['minecraft_version'],
                  'modLoaderType': self.cfg['loader']}

        try:
            request = self._make_request(url_path, params=params)
        except ValueError:
            request = []

        mods = []
        for mod_info in request:
            mod = ModrinthMod(mod_info["id"], self.cfg)
            mod._name = mod_info["name"]
            mod._downloads = mod_info["downloadCount"]
            mod._last_updated = mod_info["dateModified"][:10]
            mods.append(mod)

        self.results = iter(mods)


class ModrinthSearch():

    BASE_URL = "https://api.modrinth.com/v2"

    def __init__(self, keyword, cfg) -> None:
        self.keyword = keyword
        self.cfg = cfg
        self.results = []
        self._search()

    def __iter__(self):
        return self

    def __next__(self):
        return next(self.results)

    def _make_request(self, url_path, params=None, tries=DOWNLOAD_RETRIES):
        """
        Make a request to the curseforge API.

        Args:
            url_path (str): The url path to the resource.
            tries (int): The number of tries left.

        Returns:
            dict: The response as a json object.

        Raises:
            ValueError: If the request fails.
        """
        while tries > 0:

            end_point = f"{self.BASE_URL}{url_path}"
            headers = {"Accept": "application/json",
                       "x-api-key": self.cfg["API_KEY"]}

            try:
                response = requests.get(end_point,
                                        params=params,
                                        headers=headers,
                                        timeout=1)
                return response.json()["hits"]

            except Exception:
                sleep(DOWNLOAD_RETRIES + 1 - tries)
                tries -= 1

        raise ValueError("Too many failed requests.")

    def _search(self):

        if self.results != []:
            return self.results

        facets = [[f"versions:{self.cfg['minecraft_version']}"],
                  [f"categories:{self.cfg['loader'].lower()}"]]
        facets = repr(facets).replace(" ", "").replace("'", "\"")
        url_path = f"/search?query={self.keyword}&facets={facets}"

        try:
            request = self._make_request(url_path)
        except ValueError:
            request = []

        mods = []
        for mod_info in request:
            mod = ModrinthMod(mod_info["project_id"], self.cfg)
            mod._name = mod_info["title"]
            mod._downloads = mod_info["downloads"]
            mod._last_updated = mod_info["date_modified"][:10]
            mods.append(mod)

        self.results = iter(mods)


class ModTable:

    def __init__(self, mods):

        if not isinstance(mods, list):
            mods = [mods]

        self.mods = mods
        self._names_column_width = None
        try:
            self._term_width = os.get_terminal_size().columns
        except OSError:
            self._term_width = 80
        self._table = PrettyTable(align="l")

        if sys.platform == "win32":
            self._term_width -= 1

        self._table.set_style(SINGLE_BORDER)

    def __repr__(self):

        error_window = PrettyTable(align="c")
        error_window.header = False
        error_window.set_style(SINGLE_BORDER)

        if len(self.mods) <= 0:
            text = "No mods found.".center(self._term_width - 4)
            error_window.add_row([text])
            string = str(error_window)
        elif len(self.mods) == 1:
            string = str(self.details_view)
        else:
            string = str(self.list_view)

        if self._table_too_wide():
            text = "Window too small!".center(self._term_width - 4)
            error_window.clear_rows()
            error_window.add_row([text])
            string = str(error_window)

        return string

    def _fix_length(self, text, *, length=32):
        """
        Fix the length of a string.

        Args:
            text (str): The string to fix.
            length (int): The length to fix the string to.

        Returns:
            The fixed string.

        Raises:
            IndexError: If the length is less than 3.
        """
        # Remove all emojis from the text
        text = str(text).encode('ascii', 'ignore').decode('ascii').strip()
        output = text[:length - 3] + "..." if len(text) > length else text
        return output.ljust(length)

    def _table_too_wide(self):
        if self._term_width < 45:
            return True

        max_line_length = max(len(line)
                              for line
                              in str(self._table).split("\n"))

        return max_line_length > self._term_width

    @property
    def names_column_width(self):

        if self._names_column_width is not None:
            return self._names_column_width

        self._names_column_width = self._term_width - 40
        return self._names_column_width

    @property
    def list_view(self):

        self._table.field_names = ["Id", "Name", "Downloads", "Updated"]

        for mod in sorted(self.mods, key=lambda x: x.downloads, reverse=True):

            mod_id = mod.mod_id
            name = mod.name
            downloads = numerize(mod.downloads)
            last_updated = mod.last_updated[:10]

            row = [self._fix_length(mod_id, length=8),
                   self._fix_length(name, length=self.names_column_width),
                   self._fix_length(downloads, length=9),
                   self._fix_length(last_updated, length=10)]
            self._table.add_row(row)

        return self._table

    @property
    def details_view(self):

        # Mod fields
        mod = self.mods[0]
        mod_id = self._fix_length(mod.mod_id, length=8)
        name = self._fix_length(mod.name, length=self.names_column_width)
        downloads = self._fix_length(numerize(mod.downloads), length=9)
        last_updated = self._fix_length(mod.last_updated, length=10)

        # Title row
        title = f"{mod_id} | {name} | {downloads} | {last_updated}"
        self._table.field_names = [title]

        # Mod details
        website = mod.website
        summary = self._fix_length(mod.summary, length=self._term_width - 4)
        try:
            download_link = mod.url
        except ValueError:
            download_link = "Not available."

        # Add dependencies
        self._table.add_rows([[website], [summary], [""],
                              ["Download:"], [download_link]])

        try:
            mod_dependencies = mod.dependencies
        except ValueError:
            mod_dependencies = []

        if len(mod_dependencies) != 0:
            self._table.add_rows([[""], ["Required dependencies:"]])

        for dependency in mod_dependencies:
            mod_id = self._fix_length(dependency.mod_id, length=8)
            try:
                url = dependency.url
            except ValueError:
                url = "Not available."
            self._table.add_row([f"{mod_id} | {url}"])

        return self._table


def mod_download_wrapper(mod_or_url, cfg):
    """
    Wrapper for the mod_download function.

    Args:
        mod_or_url (Mod or str): The mod to download or a URL.
        cfg (dict): The config file as a dictionary object.
                    Needed for the destination path.
        tries (int): The number of retries if the download fails.

    Returns:
        int: The ID of the mod if the download suceeded, -1 otherwise.
             If the parameter is a string, the ID returned in case of
             success is 0.
    """
    def download_from_url(url, cfg, tries=DOWNLOAD_RETRIES):
        """
        Download a file from a URL.

        Args:
            url (str): The URL of the file.
            cfg (dict): The config file as a dictionary object.
                        Needed for the destination path.

        Returns:
            bool: True if the download was successful, raises otherwise.

        Raises:
            ValueError: If the download fails. Tries DOWNLOAD_RETRIES times.
        """
        while tries > 0:

            with requests.get(url, stream=True, timeout=1) as response:

                if response.status_code != 200:
                    sleep(DOWNLOAD_RETRIES + 1 - tries)
                    tries -= 1
                    continue

                mod_file = os.path.join(cfg["mods_path"], url.split("/")[-1])
                with open(mod_file, "wb") as file:
                    shutil.copyfileobj(response.raw, file)

                return True

        raise ValueError("Too many failed downloads.")

    mod_id = None
    name = None

    try:
        # If the variable is a Mod
        if isinstance(mod_or_url, (CurseforgeMod, ModrinthMod)):
            mod_id = mod_or_url.mod_id          # Save the ID of the Mod
            name = repr(mod_or_url)             # Save the name of the Mod
            mod_or_url = mod_or_url.url

        # If the variable is a string (URL)
        elif isinstance(mod_or_url, str):
            mod_id = 0                          # Save the ID of the URL (0)
            name = mod_or_url.split("/")[-1]    # Save the name of the URL

        # Unsupported variable type
        else:
            raise ValueError("Parameter must be Mod or string (mod_or_url).")

        download_from_url(mod_or_url, cfg, tries=DOWNLOAD_RETRIES)
        print("*", end="", flush=True)
        return mod_id

    except ValueError:
        print(f"\n- Unable to download '{name}'.", flush=True)
        return -1


def mod_dependencies_wrapper(mod):
    """
    Wrapper for the mod_dependencies function.

    Args:
        mod (Mod): The mod to get the dependencies for.

    Returns:
        set: The dependencies of the mod. {-1} in case of error.
    """
    try:
        dependencies = mod.dependencies
        print("*", end="", flush=True)
        return dependencies
    except ValueError:
        print(f"\n- Unable to get dependencies for '{mod}'.", flush=True)
        return {-1}


def build_modpack(modpack_file, cfg):
    """
    Build a modpack from a modpack file.

    Args:
        modpack_file (str): Path to the modpack file.
        cfg (dict): The config file as a dictionary object.
    """
    def process_file(modpack_file, cfg):
        """
        Process a modpack file.

        Args:
            modpack_file (str): Path to the modpack file.
            cfg (dict): The config file as a dictionary object.

        Returns:
            dict: A dictionary containing the information from the file:
                  {mods: {Mod(id=12123), ...},
                   urls: {str, ...},
                   windows_cmds: [str, ...],
                   linux_cmds: [str, ...]
                   generic_cmds: [str, ...]}
        """
        file_lines = []
        with open(modpack_file, "r") as file:
            file_lines = file.readlines()

        return {
            "mods": {Mod(line.strip().split(" ", maxsplit=1)[0], cfg)
                     for line
                     in file_lines
                     if line.strip()                          # Skip empty
                     and not line.lstrip().startswith("#")    # Skip comments
                     and not line.lstrip().startswith("$")    # Skip commands
                     and not line.lstrip().startswith("@")},  # Skip URLs

            "urls": {line[len("@"):].strip()
                     for line
                     in file_lines
                     if line.startswith("@")},

            "windows_cmds": [line[len("$ %WIN32%"):].strip()
                             for line
                             in file_lines
                             if line.lstrip().startswith("$ %WIN32%")],

            "linux_cmds": [line[len("$ %LINUX%"):].strip()
                           for line
                           in file_lines
                           if line.lstrip().startswith("$ %LINUX%")],

            "generic_cmds": [line[len("$"):].strip()
                             for line
                             in file_lines
                             if line.lstrip().startswith("$")
                             and not line.lstrip().startswith("$ %LINUX%")
                             and not line.lstrip().startswith("$ %WIN32%")]}

    def delete_files_in_folder(folder):
        """
        Delete all files in a folder.

        Args:
            folder (str): The folder to delete the files from.
        """
        for entry in os.scandir(folder):
            if entry.is_file():
                os.remove(entry.path)

    def calculate_dependencies(mods):
        """
        Calculate the dependencies of a list of mods.

        Args:
            mods (list): A list of mods.

        Returns:
            set: The dependencies of the mods.
                 Will catch any errors and print error messages.
        """
        print("Calculating dependencies...")
        dependencies = []

        with Pool() as pool:
            dependencies.extend(pool.map(mod_dependencies_wrapper, mods))

        print()

        dependencies = set(chain.from_iterable(dependencies))

        if -1 in dependencies:
            raise ValueError("Failed to get dependencies.")

        return dependencies

    def download_mods_or_urls(mods_or_urls, cfg):
        """
        Download mods or URLs.

        Args:
            mods_or_urls (list): A list of mods or URLs.
            cfg (dict): The config file as a dictionary object.

        Returns:
            list: A list of the downloaded mods.
        """
        print("Downloading mods...")
        mods = []

        with Pool() as pool:
            mods.extend(pool.starmap(mod_download_wrapper,
                                     zip(mods_or_urls,
                                         repeat(cfg))))
        print()

        return mods

    def run_commands(modpack):
        """
        Run the commands in the modpack file.
        Commands may be generic, Windows or Linux specific.

        Args:
            modpack (dict): The modpack file as a dictionary object.
        """
        print("Running custom commands...")

        commands_to_run = modpack["generic_cmds"]
        if sys.platform == "linux":
            commands_to_run += modpack["linux_cmds"]
        elif sys.platform == "win32":
            commands_to_run += modpack["windows_cmds"]

        for command in commands_to_run:
            print("*", end="", flush=True)
            process = subprocess.run([SHELL_PATH, SHELL_ARGS, command],
                                     stdout=subprocess.DEVNULL,
                                     stderr=subprocess.DEVNULL)
            if process.returncode != 0:
                print(f"\n{command}")
                print(f"- Command exited with code: {process.returncode}")

        print()

    # Process modpack file
    modpack = process_file(modpack_file, cfg)

    # Calculate dependencies
    print()
    try:
        dependencies = calculate_dependencies(modpack["mods"])
    except ValueError:
        print()
        print(f"Build FAILED for {cfg['minecraft_version']} {cfg['loader']}!")
        print("Review your configuration and modpack files and try again.")
        print(f"Configs file: {CONFIG_PATH}")
        print(f"Modpack file: {modpack_file}\n")
        return

    # Delete files in mods folder
    print(f"\nReady to build {modpack_file}\n"
          f"over Minecraft {cfg['minecraft_version']} "
          f"on {cfg['loader']}.\n")
    print("┌────────────────────────────────────────────┐")
    print("│ Warning! This will erase your mods folder! │")
    print("│ Press ENTER to continue, CTRL+C to cancel. │")
    print("└────────────────────────────────────────────┘")
    try:
        input()
        delete_files_in_folder(cfg["mods_path"])
    except KeyboardInterrupt:
        print("\nBuild cancelled.\n")
        return

    # Download mods, dependencies and URLs
    downloads = modpack["mods"] | dependencies | modpack["urls"]
    download_mods_or_urls(downloads, cfg)

    # Run commands (TODO)
    print()
    if any(modpack[k] for k in ["windows_cmds", "linux_cmds", "generic_cmds"]):
        run_commands(modpack)

    print()


def load_config():
    """
    Load the config file.
    Uses the global variables CONFIG_FOLDER, CONFIG_PATH and DEF_MODS_PATH.

    Returns:
        dict: The config file as a dictionary object.
    """
    def validate_config():
        """
        Validate the config file.
        Uses the global variable CONFIG_PATH.

        Returns:
            dict: The config file as a dictionary object.
                  {API_KEY: "...",
                   mods_path: "...",
                   minecraft_version: "...",
                   loader: "..."}

        Raises:
            ValueError: If the config file is corrupted or missing.
        """
        # Presence of the config file
        try:
            with open(CONFIG_PATH, "r") as file:
                cfg = json.load(file)
        except OSError:
            raise ValueError("Config file is corrupted or missing.")

        # Presence of the keys
        for field in ["API_KEY", "mods_path", "minecraft_version", "loader"]:
            if field in cfg:
                continue
            raise ValueError(f"{field} not found in config file.")

        # Validity of the values: API_KEY
        response = requests.get('https://api.curseforge.com/v1/games/432',
                                headers={'Accept': 'application/json',
                                         'x-api-key': cfg['API_KEY']})
        if response.status_code != 200:
            raise ValueError("Invalid API_KEY.\n       "
                             "If you just created your "
                             "account, please wait a few minutes and "
                             "try again.")

        # Mods path
        if not os.path.isdir(cfg["mods_path"].strip()):
            raise ValueError("Invalid mods_path.")

        # Loader
        if cfg["loader"].strip() not in ["Fabric", "Forge"]:
            raise ValueError("Invalid loader. Valid values: Fabric, Forge.")

        return cfg

    try:
        cfg = validate_config()
        return cfg

    except ValueError as exc:
        print(f"\nERROR: {exc}")
        api_link = "https://console.curseforge.com/?#/signup"
        print("\nOops, your config file is missing or invalid!")
        print("I'll help you fix it...\n")
        print(f"Visit {api_link} to get an API key.\n")
        field_0 = input("    What is your API key?: ")
        field_1 = input(f"    Where is your mods folder? ({DEF_MODS_PATH}): ")
        field_2 = input("    What is your Minecraft version?: ")
        field_3 = input("    Are you using Forge or Fabric?: ").capitalize()
        print("\nSaving and testing configuration...\n")

        # If path is empty, write default. Expand user path.
        if field_1.strip() == "":
            field_1 = DEF_MODS_PATH
        field_1 = os.path.expanduser(field_1)

        # Build configuration dictionary
        cfg = {"API_KEY": field_0,
               "mods_path": field_1,
               "minecraft_version": field_2,
               "loader": field_3}

        # Dump configuration to file, making the folder if it doesn't exist
        os.makedirs(CONFIG_FOLDER, exist_ok=True)
        with open(CONFIG_PATH, "w") as file:
            json.dump(cfg, file, indent=4)

        return load_config()


def main():
    """
    Main function.
    """

    # Read command line arguments
    try:
        keyword = " ".join(sys.argv[1:]).strip()
    except IndexError:
        keyword = ""

    # Load configuration
    cfg = load_config()

    # Show help message
    if keyword in {"-h", "--help"}:
        print(USAGE_INFO)

    # Build modpack
    elif os.path.isfile(keyword):
        build_modpack(keyword, cfg)

    # Either mod id or search keyword
    elif keyword != "":

        print(f"\nSearching for '{keyword}' "
              f"for {cfg['minecraft_version']} "
              f"{cfg['loader']}...")

        # Attempt to hit the mod and view its details
        try:
            mod = Mod(keyword, cfg)
            mod_table_str = str(ModTable(mod))

            if isinstance(mod, ModrinthMod):
                print("\nModrinth:")
            elif isinstance(mod, CurseforgeMod):
                print("\nCurseForge:")

            print(f"{mod_table_str}\n")

        # If you can't, then do a fuzzy search
        except ValueError:

            try:
                mods = list(CurseforgeSearch(keyword, cfg))
                print("\nCurseForge:")
                print(f"{ModTable(mods)}")

                mods = list(ModrinthSearch(keyword, cfg))
                print("\nModrinth:")
                print(f"{ModTable(mods)}\n")

            # If the search has no results, print an error message
            except ValueError:
                print("Unable to search for mods.\n")

    else:
        print(USAGE_INFO)

    sys.exit(0)


if __name__ == "__main__":
    main()
